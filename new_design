import pygame
import random
import sys
from enum import Enum

# ====================== КОНСТАНТЫ И НАСТРОЙКИ ======================
class GameSettings:
    SCREEN_WIDTH = 800
    SCREEN_HEIGHT = 600
    FPS = 60
    PLAYER_SPEED = 5
    CRASH_DURATION = 500  # мс
    BEACH_RATIO = 0.15   # доля ширины под пляж
    WATER_RATIO = 0.15   # доля ширины под воду
    LANES = 4
    DASH_LENGTH = 20
    DASH_GAP = 20

class Colors:
    SKY_BLUE    = (135, 206, 235)
    SAND_BEACH  = (240, 230, 140)
    WATER       = (0, 180, 255)
    ROAD_GRAY   = (50, 50, 50)
    WHITE       = (255, 255, 255)
    RED         = (255, 0, 0)
    GOLD        = (255, 215, 0)
    BLACK       = (0, 0, 0)
    CAR_COLORS  = [(200, 0, 0), (0, 0, 200), (0, 200, 0), (200, 200, 0)]

class ObjectType(Enum):
    CAR   = 1
    TREE  = 2
    COIN  = 3
    PALM  = 4

# ====================== ГРАФИКА И АССЕТЫ ======================
class PixelArt:
    @staticmethod
    def draw_cat(surface, x, y):
        # простой котик сверху
        pygame.draw.circle(surface, (255,165,0), (x, y), 12)      # голова
        pygame.draw.circle(surface, Colors.BLACK, (x-4, y-2), 3)   # глаз левый
        pygame.draw.circle(surface, Colors.BLACK, (x+4, y-2), 3)   # глаз правый
        pygame.draw.polygon(surface, (255,165,0), [(x-8,y-4),(x-12,y-12),(x-4,y-8)])
        pygame.draw.polygon(surface, (255,165,0), [(x+8,y-4),(x+12,y-12),(x+4,y-8)])

    @staticmethod
    def draw_car(surface, x, y, color):
        pygame.draw.rect(surface, color, (x-16, y-8, 32, 16))      # кузов
        pygame.draw.circle(surface, Colors.BLACK, (x-8, y+8), 6)   # колесо
        pygame.draw.circle(surface, Colors.BLACK, (x+8, y+8), 6)

    @staticmethod
    def draw_coin(surface, x, y):
        pygame.draw.circle(surface, Colors.GOLD, (x, y), 6)

    @staticmethod
    def draw_palm(surface, x, y):
        pygame.draw.rect(surface, (139,69,19), (x, y, 6, 20))      # ствол
        for dx, dy in [(-10,-10),(0,-20),(10,-10),(5,0),(-5,0)]:
            pygame.draw.ellipse(surface, (0,150,0), (x+dx, y+dy, 20, 10))

    @staticmethod
    def draw_environment(surface):
        W, H = GameSettings.SCREEN_WIDTH, GameSettings.SCREEN_HEIGHT
        bw = int(W * GameSettings.BEACH_RATIO)
        ww = int(W * GameSettings.WATER_RATIO)
        # пляж слева
        pygame.draw.rect(surface, Colors.SAND_BEACH, (0, 0, bw, H))
        # вода справа
        pygame.draw.rect(surface, Colors.WATER, (W-ww, 0, ww, H))
        # дорога посередине
        road_x = bw
        road_w = W - bw - ww
        pygame.draw.rect(surface, Colors.ROAD_GRAY, (road_x, 0, road_w, H))
        # полосы разметки
        lane_w = road_w / GameSettings.LANES
        for i in range(1, GameSettings.LANES):
            x = road_x + i * lane_w
            y = 0
            while y < H:
                pygame.draw.line(surface, Colors.WHITE, (x, y), (x, y + GameSettings.DASH_LENGTH), 2)
                y += GameSettings.DASH_LENGTH + GameSettings.DASH_GAP
        # пальмы на пляже
        for y in range(80, H, 150):
            PixelArt.draw_palm(surface, bw//2 - 3, y)
            PixelArt.draw_palm(surface, W-ww + ww//2 - 3, y)

# ====================== ИГРОВЫЕ ОБЪЕКТЫ ======================
class GameObject:
    def __init__(self, lane, y, obj_type, speed):
        self.lane = lane  # индекс полосы
        self.y = y
        self.type = obj_type
        self.speed = speed
        # вычисляем x по полосе
        W = GameSettings.SCREEN_WIDTH
        bw = int(W * GameSettings.BEACH_RATIO)
        ww = int(W * GameSettings.WATER_RATIO)
        road_w = W - bw - ww
        lane_w = road_w / GameSettings.LANES
        self.x = bw + lane_w * lane + lane_w/2

    def update(self):
        self.y += self.speed

    def draw(self, surface):
        if self.type == ObjectType.CAR:
            PixelArt.draw_car(surface, int(self.x), int(self.y), random.choice(Colors.CAR_COLORS))
        elif self.type == ObjectType.COIN:
            PixelArt.draw_coin(surface, int(self.x), int(self.y))

    def get_rect(self):
        return pygame.Rect(self.x-16, self.y-8, 32, 16) if self.type==ObjectType.CAR else pygame.Rect(self.x-6, self.y-6, 12, 12)

# ====================== ЭФФЕКТЫ КРЭША ======================
class CrashEffect:
    def __init__(self, x, y):
        self.x, self.y = x, y
        self.start = pygame.time.get_ticks()
    def draw(self, surface):
        t = pygame.time.get_ticks() - self.start
        if t < GameSettings.CRASH_DURATION:
            r = 30 * (1 - t/GameSettings.CRASH_DURATION)
            pygame.draw.circle(surface, Colors.RED, (int(self.x), int(self.y)), int(r), 3)
            return True
        return False

# ====================== ИГРОВАЯ ЛОГИКА ======================
class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((GameSettings.SCREEN_WIDTH,GameSettings.SCREEN_HEIGHT))
        pygame.display.set_caption("Top-Down Road Runner")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.SysFont("Arial", 20)
        self.reset_game()

    def reset_game(self):
        self.player_pos = (GameSettings.SCREEN_WIDTH//2, GameSettings.SCREEN_HEIGHT - 50)
        self.score = 0
        self.level = 1
        self.cars = []
        self.coins = []
        self.crashes = []
        self.game_active = True
        self.last_car = 0
        self.last_coin = 0

    def generate(self):
        now = pygame.time.get_ticks()
        # машины
        if now - self.last_car > random.randint(800,1500):
            lane = random.randrange(GameSettings.LANES)
            speed = random.randint(3,6) + self.level//5
            self.cars.append(GameObject(lane, -20, ObjectType.CAR, speed))
            self.last_car = now
        # монеты
        if now - self.last_coin > random.randint(500,1000):
            lane = random.randrange(GameSettings.LANES)
            speed = random.randint(2,4)
            self.coins.append(GameObject(lane, -20, ObjectType.COIN, speed))
            self.last_coin = now

    def update(self):
        # обновим позиции
        for car in self.cars[:]:
            car.update()
            if car.y > GameSettings.SCREEN_HEIGHT: self.cars.remove(car)
        for coin in self.coins[:]:
            coin.update()
            if coin.y > GameSettings.SCREEN_HEIGHT: self.coins.remove(coin)
        # крэши между машинами
        for i in range(len(self.cars)):
            for j in range(i+1,len(self.cars)):
                if self.cars[i].get_rect().colliderect(self.cars[j].get_rect()):
                    mx = (self.cars[i].x + self.cars[j].x)/2
                    my = (self.cars[i].y + self.cars[j].y)/2
                    self.crashes.append(CrashEffect(mx, my))
        # удаляем эффекты
        self.crashes = [c for c in self.crashes if c.draw(self.screen)]

    def check(self):
        pr = pygame.Rect(self.player_pos[0]-12, self.player_pos[1]-12, 24, 24)
        # машины
        for car in self.cars:
            if pr.colliderect(car.get_rect()): self.game_active = False
        # монеты
        for coin in self.coins[:]:
            if pr.colliderect(coin.get_rect()):
                self.coins.remove(coin); self.score += 1
                if self.score % 10 == 0: self.level += 1

    def draw(self):
        PixelArt.draw_environment(self.screen)
        # объекты
        for car in self.cars:   car.draw(self.screen)
        for coin in self.coins: coin.draw(self.screen)
        # игрок
        PixelArt.draw_cat(self.screen, *self.player_pos)
        # UI
        self.screen.blit(self.font.render(f"Score: {self.score}",True,Colors.BLACK),(10,10))
        self.screen.blit(self.font.render(f"Level: {self.level}",True,Colors.BLACK),(10,40))
        # крэши
        for c in self.crashes: c.draw(self.screen)
        # Game Over
        if not self.game_active:
            over = self.font.render("Game Over! Press R to restart",True,Colors.RED)
            self.screen.blit(over,((GameSettings.SCREEN_WIDTH-over.get_width())//2,GameSettings.SCREEN_HEIGHT//2))

    def run(self):
        while True:
            for e in pygame.event.get():
                if e.type==pygame.QUIT: pygame.quit(); sys.exit()
                if e.type==pygame.KEYDOWN and not self.game_active and e.key==pygame.K_r:
                    self.reset_game()
            if self.game_active:
                self.generate()
                self.update()
                self.check()
            self.draw()
            pygame.display.flip()
            self.clock.tick(GameSettings.FPS)

if __name__=="__main__":
    Game().run()
